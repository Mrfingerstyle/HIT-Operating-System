### 多进程图像
---
- 什么是多进程图像 ？
---
- 如何使用CPU ？
> 程序执行起来
- 如何充分使用CPU ?
> 启动多个程序 交替执行
> 启动了的程序就是进程 所以是多个进程推进
> 操作系统只需要把这些进程记录好 要按照合理的次序推进
> 分配资源、进行调度
- 这就是多进程图像
---
- 多进程图像从启动开始到关机结束
1. main中的fork()创建第一个进程
```
if(!fork()) {init();}
```
> init执行shell(window桌面)
2. shell再启动其他进程
---
- 操作系统为了实现多进程图像应该做什么 ？如何组织 ？
> PCB process control block 记录进程信息的控制结构
---
> 有一个进程在执行
---
> 物理CPU
>> PCB
>> Registers
---
> 有一些队列等待执行
> 就绪队列
---
> 有一些进程在等待事件
> 磁盘等待队列
---
- 多进程的组织 PCB + 状态 + 队列
> 运行 -> 阻塞
> 运行 -> 就绪
> 就绪 -> 运行
- 进程状态图
1. 它给出进程生存期的清晰描述
2. 认识操作系统进程管理的一个窗口
```
新建态 -> 就绪态 -> 运行态 -> 终止态
            ->   ->
              阻塞态 
```
---
- 多进程如何交替
```C
启动磁盘读写;
pCur.state = 'W';
将pCur放到DiskWaitQueue;
schedule();
```
```C
schedule() {
    // 调度
    pNew = getNext(ReadyQueue);
    switch_to(pCur, pNew);
}
```
---
### 交替的三个部分 队列操作 + 调度 + 切换
- FIFO?
> 显然是公平的策略
> 但是没有考虑进程执行任务的区别
- Priority?
> 优先级如何确定?可能是某些进程饥饿
---
### 多个进程如何影响 ？
> 多个进程同时存在于内存中
> 进程的内存地址互相影响 可能会修改对方的数据
- 解决方法
> 限制对特定地址的读写
> 多进程的地址空间分离: 内存管理的主要内容
> 基本思想是通过映射表
> 进程带动内存的使用
> 进程映射表限制物理内存的访问范围 
### 多进程如何合作 ？
> 进程同步与合作
> 生产者-消费者实例
> 核心在进程同步(合理的推进顺序)
> 写counter时阻断其他进程访问counter
### 如何形成多进程图像 ?
- 读写PCB OS中最重要的结构 贯穿始终
- 操作寄存器完成切换
- 写调度程序
- 进程同步与合作
- 地址映射
