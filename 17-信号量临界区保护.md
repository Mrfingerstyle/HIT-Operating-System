### 信号量临界区保护
---
#### 使用临界区保护信号量
- 临界区保护信号量 信号量实现进程的同步
---
- 为什么保护信号量 为什么引出临界区概念
---
- 共同修改信号量引出的问题
- 竞争条件 和调度有关的共享数据语义错误
- 错误由多个进程并发操作共享数据引起 
- 错误和调度顺序有关 难于发现和调试
---
- 解决竞争条件的直观想法
- 在写共享变量的empty时阻止其他进程也访问empty
- 检查并给empty上锁
- 原子操作
- 一段代码一次只允许一个进程进入
---
#### 临界区
- 一次只允许一个进程进入的该进程的那一段代码
- 这就是临界区
- 重要工作: 找出进程中的临界区代码
- 读写信号量的代码一定是临界区
- 进程代码结构
> 剩余区
>> 进入区
>> 临界区
>> 退出区
---
### 进入临界区和退出临界区的代码是核心
- 基本原则 互斥进入 一个进程在临界区执行 其他进程不能进入
- 进程间的约束关系称为互斥
- 这保证了临界区
- 好的临界区原则
> 有空快进 若干进程要求进入空闲临界区 应尽快使一进程进入临界区
> 有限等待 从进程发出进入申请到允许进入 不能无限等待
---
### 进入临界区的一个尝试-轮换法
```C
// 进程P0
while(turn! = 0);
turn = 1;
```
```C
// 进程P1
while(turn! = 1);
turn = 0;
```
### 另一个方法-标记法
- 两个进程互旋 谁也进不去
- P0 P1的进入请求会无限等待
```C
// 进程P0
flag[0] = true;
while(flag[1]);
// 临界区
flag[0] = false;
// 剩余区
```
```C
// 进程P1
flag[1] = true;
while(flag[0]);
// 临界区
flag[1] = false;
// 剩余区
```
### 再一次尝试-非对称标记
- 结合标记和轮转两种思想
- 进入临界区peterson算法
- 该算法的正确性
- 互斥进入 有空让进 有限等待
```C
// 进程P0
flag[0] = true;
turn = 1;
while(flag[1] && turn == 1);
// 临界区
flag[0] = false;
// 剩余区
```
```C
// 进程P1
flag[1] = true;
turn = 0;
while(flag[1] && turn == 0);
// 临界区
flag[1] = false;
// 剩余区
```
### 多个进程怎么办-面包店算法
- 仍然是标记和轮转的结合
- 如何轮转 每个进程都获得一个序号 序号最小的进入
- 如何标记 进程离开时序号为0 不为0的序号即标记
- 面包店算法
- 每个进点的客户获得一个号码 号码最小的先获得服务 
- 号码相同时 名字靠前先服务
- 面包店算法的正确性
### 硬件实现
1. 第一种硬件方法
- cli() 清除中断
- sti() 恢复中断
- 在多CPU时不好使用 多个CPU不好控制
2. 硬件原子指令法
- 锁是变量
```C
testandset(boolean &x) {
    boolean rv = x;
    x = true;
    return rv;
}
while(testandset(&lock));
// 临界区
lock = false;
// 剩余区
```
---
### 临界区保护信号量 信号量实现同步










